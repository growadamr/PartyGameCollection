---
phase: 02-voting-elimination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/games/imposter.gd
  - scenes/games/imposter/imposter.tscn
autonomous: true

must_haves:
  truths:
    - "Host receives vote_cast messages and updates vote dictionary"
    - "Vote changes trigger broadcast of updated tallies to all clients"
    - "Consensus detection fires when all eligible voters except target vote for same person"
    - "5-second countdown starts on consensus, can be cancelled if consensus breaks"
    - "Reveal sequence shows dramatic pause then result"
    - "Eliminated players cannot vote"
  artifacts:
    - path: "scripts/games/imposter.gd"
      provides: "Voting state machine with consensus detection"
      contains: "enum State"
    - path: "scenes/games/imposter/imposter.tscn"
      provides: "Timer nodes for countdown and consensus check"
      contains: "CountdownTimer"
  key_links:
    - from: "scripts/games/imposter.gd"
      to: "NetworkManager.broadcast"
      via: "_broadcast_vote_state function"
      pattern: "NetworkManager\\.broadcast"
    - from: "scripts/games/imposter.gd"
      to: "NetworkManager.send_to_client"
      via: "word_revealed for eliminated imposters"
      pattern: "send_to_client"
---

<objective>
Implement host-side voting state machine with consensus detection and reveal sequence.

Purpose: Enable the core voting mechanics where players vote for suspected imposters, with the host managing all state transitions and broadcasting updates to clients.

Output: Extended imposter.gd with voting state machine, consensus detection, countdown timers, and reveal logic. Scene file updated with required Timer nodes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-voting-elimination/02-RESEARCH.md
@.planning/phases/02-voting-elimination/02-CONTEXT.md

@scripts/games/imposter.gd
@scenes/games/imposter/imposter.tscn
@scripts/autoload/network_manager.gd
@scripts/games/charades.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Timer nodes to imposter.tscn</name>
  <files>scenes/games/imposter/imposter.tscn</files>
  <action>
Add two Timer nodes to the scene:
1. `CountdownTimer` - for the 5-second consensus warning countdown (one_shot: false, wait_time: 1.0)
2. `ConsensusCheckTimer` - for debouncing consensus checks (one_shot: true, wait_time: 0.1)

Add these as direct children of the root Imposter node, after PlayersStatus.

Follow the pattern from charades.gd which uses @onready var turn_timer: Timer = $TurnTimer.
  </action>
  <verify>Open the scene in Godot editor or check the .tscn file contains both Timer nodes with correct properties.</verify>
  <done>imposter.tscn contains CountdownTimer and ConsensusCheckTimer nodes with appropriate settings.</done>
</task>

<task type="auto">
  <name>Task 2: Implement voting state machine in imposter.gd</name>
  <files>scripts/games/imposter.gd</files>
  <action>
Extend imposter.gd with the voting state machine. Add:

1. **State enum and variables:**
```gdscript
enum State { DISCUSSION, VOTING, CONSENSUS_WARNING, REVEALING, RESULT_DISPLAY }

var current_state: State = State.DISCUSSION
var votes: Dictionary = {}              # voter_id -> target_id
var eliminated_players: Array = []      # List of eliminated player IDs
var consensus_target: String = ""       # Current consensus target
var countdown_remaining: int = 5        # Consensus countdown
var remaining_imposters: int = 0        # Living imposters count
```

2. **Timer references and connections in _ready():**
```gdscript
@onready var countdown_timer: Timer = $CountdownTimer
@onready var consensus_check_timer: Timer = $ConsensusCheckTimer
```
Connect timer signals in _ready():
- countdown_timer.timeout.connect(_on_countdown_timer_timeout)
- consensus_check_timer.timeout.connect(_on_consensus_check_timer_timeout)

3. **Initialize remaining_imposters** in _initialize_game() after selecting imposters:
```gdscript
remaining_imposters = imposter_count
```

4. **Start voting function** - call this after discussion phase ends (for now, add a transition method that can be triggered):
```gdscript
func start_voting() -> void:
    if not GameManager.is_host:
        return

    current_state = State.VOTING
    votes.clear()

    var player_list = []
    for player_id in GameManager.players:
        var p = GameManager.players[player_id]
        player_list.append({
            "id": player_id,
            "name": p.get("name", "Unknown"),
            "eliminated": player_id in eliminated_players
        })

    NetworkManager.broadcast({
        "type": "voting_started",
        "players": player_list,
        "eliminated": eliminated_players
    })
```

5. **Message handler additions** in _on_message_received():
```gdscript
"vote_cast":
    if GameManager.is_host:
        var voter_id = "peer_%d" % _peer_id
        _process_vote(voter_id, data.get("target_id", ""))
"voting_started":
    _apply_voting_started(data)
"vote_update":
    _apply_vote_update(data)
"consensus_warning":
    _apply_consensus_warning(data)
"consensus_countdown":
    _apply_consensus_countdown(data)
"consensus_cancelled":
    _apply_consensus_cancelled()
"reveal_start":
    _apply_reveal_start(data)
"reveal_result":
    _apply_reveal_result(data)
```

6. **Vote processing:**
```gdscript
func _can_vote(voter_id: String) -> bool:
    return voter_id not in eliminated_players and current_state in [State.VOTING, State.CONSENSUS_WARNING]

func _process_vote(voter_id: String, target_id: String) -> void:
    if not _can_vote(voter_id):
        return
    if target_id == "" or not GameManager.players.has(target_id):
        return
    if target_id in eliminated_players:
        return

    votes[voter_id] = target_id
    _broadcast_vote_state()
    _check_consensus()

func _broadcast_vote_state() -> void:
    var tallies: Dictionary = {}
    for voter_id in votes:
        var target = votes[voter_id]
        tallies[target] = tallies.get(target, 0) + 1

    NetworkManager.broadcast({
        "type": "vote_update",
        "votes": votes,
        "tallies": tallies,
        "state": State.keys()[current_state].to_lower()
    })
```

7. **Consensus detection with debounce:**
```gdscript
func _check_consensus() -> void:
    if consensus_check_timer.is_stopped():
        consensus_check_timer.start()

func _on_consensus_check_timer_timeout() -> void:
    var eligible_voters = _get_eligible_voters()
    var vote_counts: Dictionary = {}

    for voter_id in votes:
        if voter_id in eligible_voters:
            var target = votes[voter_id]
            vote_counts[target] = vote_counts.get(target, 0) + 1

    for target_id in vote_counts:
        var voters_excluding_target = eligible_voters.filter(func(v): return v != target_id)
        if vote_counts[target_id] == voters_excluding_target.size() and voters_excluding_target.size() > 0:
            _start_consensus_warning(target_id)
            return

    if current_state == State.CONSENSUS_WARNING:
        _cancel_consensus_warning()

func _get_eligible_voters() -> Array:
    var eligible = []
    for player_id in GameManager.players:
        if player_id not in eliminated_players:
            eligible.append(player_id)
    return eligible
```

8. **Consensus warning and countdown:**
```gdscript
func _start_consensus_warning(target_id: String) -> void:
    if current_state == State.CONSENSUS_WARNING and consensus_target == target_id:
        return  # Already warning for this target

    consensus_target = target_id
    current_state = State.CONSENSUS_WARNING
    countdown_remaining = 5
    countdown_timer.start(1.0)

    var target_data = GameManager.players.get(target_id, {})
    NetworkManager.broadcast({
        "type": "consensus_warning",
        "target_id": target_id,
        "target_name": target_data.get("name", "Unknown"),
        "countdown": countdown_remaining
    })

func _on_countdown_timer_timeout() -> void:
    countdown_remaining -= 1

    if countdown_remaining <= 0:
        countdown_timer.stop()
        _start_reveal()
    else:
        NetworkManager.broadcast({
            "type": "consensus_countdown",
            "countdown": countdown_remaining
        })

func _cancel_consensus_warning() -> void:
    countdown_timer.stop()
    consensus_target = ""
    current_state = State.VOTING

    NetworkManager.broadcast({
        "type": "consensus_cancelled"
    })
```

9. **Reveal sequence:**
```gdscript
func _start_reveal() -> void:
    current_state = State.REVEALING

    var target_data = GameManager.players.get(consensus_target, {})
    NetworkManager.broadcast({
        "type": "reveal_start",
        "target_id": consensus_target,
        "target_name": target_data.get("name", "Unknown")
    })

    # Dramatic pause before result
    await get_tree().create_timer(2.0).timeout
    _show_reveal_result()

func _show_reveal_result() -> void:
    current_state = State.RESULT_DISPLAY

    var target_id = consensus_target
    var is_imposter = player_roles.get(target_id, false)
    var target_data = GameManager.players.get(target_id, {})

    if is_imposter:
        eliminated_players.append(target_id)
        remaining_imposters -= 1

        # Send word to eliminated imposter
        var peer_id = _get_peer_id_for_player(target_id)
        NetworkManager.send_to_client(peer_id, {
            "type": "word_revealed",
            "word": current_word
        })

    NetworkManager.broadcast({
        "type": "reveal_result",
        "target_id": target_id,
        "target_name": target_data.get("name", "Unknown"),
        "is_imposter": is_imposter,
        "remaining_imposters": remaining_imposters
    })

    # Clear vote from eliminated player if any
    votes.erase(target_id)

    # Wait then continue
    await get_tree().create_timer(4.0).timeout
    _after_reveal()

func _after_reveal() -> void:
    consensus_target = ""

    # Check if game should end (Phase 3 will handle this properly)
    # For now, just return to voting if game continues
    if remaining_imposters > 0 and _get_eligible_voters().size() > 2:
        current_state = State.VOTING
        votes.clear()
        _broadcast_vote_state()

        NetworkManager.broadcast({
            "type": "voting_resumed",
            "votes": votes,
            "tallies": {}
        })
```

10. **Apply functions for non-host clients:**
```gdscript
func _apply_voting_started(data: Dictionary) -> void:
    current_state = State.VOTING
    # UI update will be handled by web player

func _apply_vote_update(data: Dictionary) -> void:
    votes = data.get("votes", {})
    # State sync for non-host Godot clients

func _apply_consensus_warning(data: Dictionary) -> void:
    current_state = State.CONSENSUS_WARNING
    consensus_target = data.get("target_id", "")
    countdown_remaining = data.get("countdown", 5)

func _apply_consensus_countdown(data: Dictionary) -> void:
    countdown_remaining = data.get("countdown", 0)

func _apply_consensus_cancelled() -> void:
    current_state = State.VOTING
    consensus_target = ""

func _apply_reveal_start(data: Dictionary) -> void:
    current_state = State.REVEALING

func _apply_reveal_result(data: Dictionary) -> void:
    current_state = State.RESULT_DISPLAY
    var target_id = data.get("target_id", "")
    var is_imposter = data.get("is_imposter", false)
    remaining_imposters = data.get("remaining_imposters", 0)

    if is_imposter and target_id not in eliminated_players:
        eliminated_players.append(target_id)
```

Important: Do NOT remove or break existing Phase 1 functionality. The voting state machine extends the existing code.
  </action>
  <verify>
Run the game with print statements or check:
1. Script compiles without errors in Godot
2. State enum exists
3. Message handlers are in the match statement
4. Timer connections are in _ready()
  </verify>
  <done>
imposter.gd contains:
- State enum with DISCUSSION, VOTING, CONSENSUS_WARNING, REVEALING, RESULT_DISPLAY
- Vote processing that validates voter eligibility
- Consensus detection with 100ms debounce
- 5-second countdown that can be cancelled
- Reveal sequence with dramatic pause
- Eliminated imposter sees word via word_revealed message
  </done>
</task>

<task type="auto">
  <name>Task 3: Add start_voting trigger for testing</name>
  <files>scripts/games/imposter.gd</files>
  <action>
Add a temporary way to trigger voting for testing. In _on_message_received, add:

```gdscript
"start_voting":
    if GameManager.is_host:
        start_voting()
```

Also add keyboard shortcut for host testing in _ready():
```gdscript
func _input(event: InputEvent) -> void:
    if GameManager.is_host and event is InputEventKey and event.pressed:
        if event.keycode == KEY_V and current_state == State.DISCUSSION:
            start_voting()
```

This allows pressing 'V' on the host to start voting phase for testing.
  </action>
  <verify>Run the game, press V during discussion phase, verify voting_started message is broadcast.</verify>
  <done>Host can trigger voting phase with V key or start_voting message for testing.</done>
</task>

</tasks>

<verification>
1. Open project in Godot, verify no script errors
2. Start imposter game with 3+ players (can use multiple browser tabs)
3. Press V to start voting
4. Verify web players receive voting_started message (check browser console)
5. Test vote_cast from web player (Phase 2 Plan 02/03 will add UI)
</verification>

<success_criteria>
- State machine transitions correctly: DISCUSSION -> VOTING -> CONSENSUS_WARNING -> REVEALING -> RESULT_DISPLAY
- Votes are tracked in Dictionary, broadcasts update all clients
- Consensus detection triggers after 100ms debounce
- 5-second countdown broadcasts each tick
- Consensus breaking cancels countdown and returns to VOTING
- Reveal shows imposter/innocent result
- Eliminated imposters receive word_revealed message
- Requirements covered: VOTE-01 (partial - host logic), VOTE-02 (partial - broadcast), VOTE-03 (partial - host allows), VOTE-04, ELIM-01, ELIM-02, ELIM-03, ELIM-04
</success_criteria>

<output>
After completion, create `.planning/phases/02-voting-elimination/02-01-SUMMARY.md`
</output>
