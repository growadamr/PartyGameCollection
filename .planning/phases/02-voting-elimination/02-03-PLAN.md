---
phase: 02-voting-elimination
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - web-player/js/games/imposter.js
autonomous: true

must_haves:
  truths:
    - "Players can tap any non-eliminated player to cast vote"
    - "Vote counts update in real-time as host broadcasts changes"
    - "Players can change vote by tapping different player"
    - "Own vote shows highlighted border"
    - "Consensus warning displays with countdown"
    - "Reveal shows dramatic pause then result with correct color"
    - "Eliminated players see spectator view with word revealed"
  artifacts:
    - path: "web-player/js/games/imposter.js"
      provides: "Complete voting UI handlers"
      exports: ["ImposterGame"]
      min_lines: 150
  key_links:
    - from: "web-player/js/games/imposter.js"
      to: "gameSocket.send"
      via: "castVote method"
      pattern: "gameSocket\\.send.*vote_cast"
    - from: "web-player/js/games/imposter.js"
      to: "DOM elements"
      via: "getElementById calls"
      pattern: "getElementById.*vote-player-list"
---

<objective>
Implement JavaScript handlers for voting UI in the web player.

Purpose: Connect the UI structure to the host's voting state machine, handling all message types and providing real-time vote updates, consensus warnings, and reveal sequences.

Output: Extended imposter.js with complete voting functionality including vote casting, state rendering, and view transitions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-voting-elimination/02-RESEARCH.md
@.planning/phases/02-voting-elimination/02-CONTEXT.md
@.planning/phases/02-voting-elimination/02-01-PLAN.md
@.planning/phases/02-voting-elimination/02-02-PLAN.md

@web-player/js/games/imposter.js
@web-player/js/websocket.js
@web-player/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state variables and socket handlers</name>
  <files>web-player/js/games/imposter.js</files>
  <action>
Extend the ImposterGame class. Add new state variables in constructor:

```javascript
constructor() {
    this.app = null;
    this.isImposter = false;
    this.secretWord = "";
    this.imposterCount = 0;
    this.totalPlayers = 0;

    // Voting state (new)
    this.currentState = 'discussion';  // discussion, voting, consensus_warning, revealing, result
    this.votes = {};                    // Synced from host: voter_id -> target_id
    this.tallies = {};                  // Synced from host: player_id -> vote_count
    this.myVote = null;                 // Current player's vote target
    this.players = [];                  // Player list from voting_started
    this.consensusTarget = null;        // Who is being accused
    this.countdown = 5;                 // Countdown remaining
    this.isEliminated = false;          // Is current player eliminated
    this.myPlayerId = null;             // Will be set from app
}
```

In setupSocketHandlers(), add handlers for all voting message types:

```javascript
setupSocketHandlers() {
    // Existing handlers
    gameSocket.on('imposter_role', (data) => {
        this.handleRoleAssignment(data);
    });

    gameSocket.on('discussion_started', (data) => {
        this.updateDiscussionUI();
    });

    // Voting handlers (new)
    gameSocket.on('voting_started', (data) => {
        this.handleVotingStarted(data);
    });

    gameSocket.on('vote_update', (data) => {
        this.handleVoteUpdate(data);
    });

    gameSocket.on('consensus_warning', (data) => {
        this.handleConsensusWarning(data);
    });

    gameSocket.on('consensus_countdown', (data) => {
        this.handleConsensusCountdown(data);
    });

    gameSocket.on('consensus_cancelled', (data) => {
        this.handleConsensusCancelled();
    });

    gameSocket.on('reveal_start', (data) => {
        this.handleRevealStart(data);
    });

    gameSocket.on('reveal_result', (data) => {
        this.handleRevealResult(data);
    });

    gameSocket.on('voting_resumed', (data) => {
        this.handleVotingResumed(data);
    });

    gameSocket.on('word_revealed', (data) => {
        this.handleWordRevealed(data);
    });
}
```
  </action>
  <verify>Check imposter.js has all state variables and socket handlers registered.</verify>
  <done>ImposterGame has voting state variables and socket handlers for all message types.</done>
</task>

<task type="auto">
  <name>Task 2: Implement view management and voting handlers</name>
  <files>web-player/js/games/imposter.js</files>
  <action>
Add view management helper and implement voting handlers:

```javascript
// View management
showView(viewId) {
    const views = [
        'imposter-role-view',
        'imposter-voting-view',
        'imposter-spectator-view',
        'imposter-consensus-view',
        'imposter-reveal-view',
        'imposter-result-view'
    ];

    views.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.classList.toggle('hidden', id !== viewId);
        }
    });
}

// Voting started handler
handleVotingStarted(data) {
    this.currentState = 'voting';
    this.players = data.players || [];
    this.votes = {};
    this.tallies = {};
    this.myVote = null;

    // Get my player ID from app if available
    if (this.app && this.app.playerId) {
        this.myPlayerId = this.app.playerId;
    }

    // Check if I'm eliminated
    const eliminated = data.eliminated || [];
    this.isEliminated = eliminated.includes(this.myPlayerId);

    if (this.isEliminated) {
        this.showSpectatorView();
    } else {
        this.showVotingView();
    }
}

// Show voting view and populate player list
showVotingView() {
    this.showView('imposter-voting-view');
    this.renderVoteList('vote-player-list', true);
}

// Show spectator view for eliminated players
showSpectatorView() {
    this.showView('imposter-spectator-view');

    // Show the word if we're an eliminated imposter
    const wordDisplay = document.getElementById('spectator-word-display');
    if (wordDisplay) {
        if (this.secretWord) {
            wordDisplay.textContent = `The word was: ${this.secretWord}`;
        } else {
            wordDisplay.textContent = '';
        }
    }

    this.renderVoteList('spectator-vote-list', false);
}

// Render vote list (reusable for voting and spectator views)
renderVoteList(containerId, interactive) {
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = '';

    this.players.forEach(player => {
        const div = document.createElement('div');
        div.className = 'vote-option';
        div.dataset.playerId = player.id;

        // Add eliminated class
        if (player.eliminated) {
            div.classList.add('eliminated');
        }

        // Add my-vote class if this is who I voted for
        if (this.myVote === player.id) {
            div.classList.add('my-vote');
        }

        // Don't show self in vote list (can't vote for yourself in UI, though host allows it)
        // Actually per research, self-votes are allowed. Keep self in list.

        const voteCount = this.tallies[player.id] || 0;

        div.innerHTML = `
            <span class="player-name">${player.name}</span>
            <span class="vote-count ${voteCount === 0 ? 'zero' : ''}">${voteCount}</span>
        `;

        // Add click handler if interactive and not eliminated
        if (interactive && !player.eliminated && !this.isEliminated) {
            div.addEventListener('click', () => this.castVote(player.id));
        }

        container.appendChild(div);
    });
}

// Cast a vote
castVote(targetId) {
    if (this.isEliminated) return;
    if (this.currentState !== 'voting' && this.currentState !== 'consensus_warning') return;

    this.myVote = targetId;

    gameSocket.send({
        type: 'vote_cast',
        target_id: targetId
    });

    // Optimistically update UI
    this.updateVoteHighlight();
}

// Update just the vote highlight (my-vote class)
updateVoteHighlight() {
    const container = document.getElementById(this.isEliminated ? 'spectator-vote-list' : 'vote-player-list');
    if (!container) return;

    container.querySelectorAll('.vote-option').forEach(el => {
        el.classList.toggle('my-vote', el.dataset.playerId === this.myVote);
    });
}

// Handle vote update from host
handleVoteUpdate(data) {
    this.votes = data.votes || {};
    this.tallies = data.tallies || {};
    this.currentState = data.state || 'voting';

    // Update my vote from server state
    if (this.myPlayerId && this.votes[this.myPlayerId]) {
        this.myVote = this.votes[this.myPlayerId];
    }

    // Re-render vote counts
    this.updateVoteCounts();
    this.updateVoteHighlight();
}

// Update vote counts without full re-render
updateVoteCounts() {
    const containerId = this.isEliminated ? 'spectator-vote-list' : 'vote-player-list';
    const container = document.getElementById(containerId);
    if (!container) return;

    container.querySelectorAll('.vote-option').forEach(el => {
        const playerId = el.dataset.playerId;
        const countEl = el.querySelector('.vote-count');
        if (countEl) {
            const count = this.tallies[playerId] || 0;
            countEl.textContent = count;
            countEl.classList.toggle('zero', count === 0);
        }
    });
}
```
  </action>
  <verify>Check that showView, handleVotingStarted, renderVoteList, castVote, and handleVoteUpdate are all implemented.</verify>
  <done>View management and core voting handlers implemented with real-time vote count updates.</done>
</task>

<task type="auto">
  <name>Task 3: Implement consensus, reveal, and result handlers</name>
  <files>web-player/js/games/imposter.js</files>
  <action>
Add handlers for consensus warning, reveal, and result phases:

```javascript
// Consensus warning handler
handleConsensusWarning(data) {
    this.currentState = 'consensus_warning';
    this.consensusTarget = data.target_id;
    this.countdown = data.countdown || 5;

    // Update target name
    const nameEl = document.getElementById('consensus-target-name');
    if (nameEl) {
        nameEl.textContent = data.target_name || 'Unknown';
    }

    // Update countdown
    const countdownEl = document.getElementById('consensus-countdown');
    if (countdownEl) {
        countdownEl.textContent = this.countdown;
    }

    this.showView('imposter-consensus-view');
}

// Countdown tick handler
handleConsensusCountdown(data) {
    this.countdown = data.countdown || 0;

    const countdownEl = document.getElementById('consensus-countdown');
    if (countdownEl) {
        countdownEl.textContent = this.countdown;
    }
}

// Consensus cancelled handler
handleConsensusCancelled() {
    this.currentState = 'voting';
    this.consensusTarget = null;

    // Return to appropriate view
    if (this.isEliminated) {
        this.showSpectatorView();
    } else {
        this.showVotingView();
    }
}

// Reveal start handler
handleRevealStart(data) {
    this.currentState = 'revealing';

    const nameEl = document.getElementById('reveal-target-name');
    if (nameEl) {
        nameEl.textContent = data.target_name || 'Unknown';
    }

    this.showView('imposter-reveal-view');
}

// Reveal result handler
handleRevealResult(data) {
    this.currentState = 'result';

    const targetId = data.target_id;
    const targetName = data.target_name || 'Unknown';
    const isImposter = data.is_imposter;
    const remainingImposters = data.remaining_imposters || 0;

    // Update result card
    const resultCard = document.getElementById('result-card');
    const nameEl = document.getElementById('result-player-name');
    const roleEl = document.getElementById('result-role-text');
    const remainingEl = document.getElementById('result-remaining');

    if (resultCard) {
        resultCard.classList.remove('imposter', 'innocent');
        resultCard.classList.add(isImposter ? 'imposter' : 'innocent');
    }

    if (nameEl) {
        nameEl.textContent = targetName;
    }

    if (roleEl) {
        roleEl.textContent = isImposter ? 'was an IMPOSTER!' : 'was INNOCENT!';
    }

    if (remainingEl) {
        if (remainingImposters === 0) {
            remainingEl.textContent = 'All imposters found!';
        } else if (remainingImposters === 1) {
            remainingEl.textContent = '1 imposter remaining';
        } else {
            remainingEl.textContent = `${remainingImposters} imposters remaining`;
        }
    }

    // Check if I was the one eliminated
    if (targetId === this.myPlayerId && isImposter) {
        this.isEliminated = true;
    }

    // Update player list to mark eliminated
    const player = this.players.find(p => p.id === targetId);
    if (player && isImposter) {
        player.eliminated = true;
    }

    this.showView('imposter-result-view');
}

// Voting resumed handler (after result display)
handleVotingResumed(data) {
    this.currentState = 'voting';
    this.votes = data.votes || {};
    this.tallies = data.tallies || {};
    this.consensusTarget = null;
    this.myVote = null;

    if (this.isEliminated) {
        this.showSpectatorView();
    } else {
        this.showVotingView();
    }
}

// Word revealed handler (for eliminated imposters)
handleWordRevealed(data) {
    this.secretWord = data.word || '';

    // Update spectator word display if visible
    const wordDisplay = document.getElementById('spectator-word-display');
    if (wordDisplay) {
        wordDisplay.textContent = `The word was: ${this.secretWord}`;
    }
}
```

Also update the init method to capture player ID:

```javascript
init(app) {
    this.app = app;
    // Try to get player ID from app (set after join)
    if (app && app.playerId) {
        this.myPlayerId = app.playerId;
    }
    this.setupSocketHandlers();
}
```

And update handleRoleAssignment to reset state for new game:

```javascript
handleRoleAssignment(data) {
    // Reset voting state for new game
    this.currentState = 'discussion';
    this.votes = {};
    this.tallies = {};
    this.myVote = null;
    this.isEliminated = false;
    this.consensusTarget = null;
    this.players = [];

    // Existing role assignment logic
    this.isImposter = data.is_imposter;
    this.secretWord = data.word || "";
    this.imposterCount = data.imposter_count || 1;
    this.totalPlayers = data.total_players || 0;

    this.showRoleScreen();
}
```

Finally, update showRoleScreen to use the new view system:

```javascript
showRoleScreen() {
    // Show the role view
    this.showView('imposter-role-view');

    const roleLabel = document.getElementById('imposter-role-label');
    const wordDisplay = document.getElementById('imposter-word');
    const imposterInfo = document.getElementById('imposter-info');
    const instructionLabel = document.getElementById('imposter-instruction');

    // Update imposter count info
    if (imposterInfo) {
        const plural = this.imposterCount > 1 ? 'imposters' : 'imposter';
        imposterInfo.textContent = `There ${this.imposterCount > 1 ? 'are' : 'is'} ${this.imposterCount} ${plural} among you`;
    }

    if (this.isImposter) {
        if (roleLabel) {
            roleLabel.textContent = "You are an IMPOSTER!";
            roleLabel.className = 'role-label imposter';
        }
        if (wordDisplay) {
            wordDisplay.textContent = "IMPOSTER";
            wordDisplay.className = 'prompt-card large imposter';
        }
        if (instructionLabel) {
            instructionLabel.textContent = "Blend in! Figure out the secret word without revealing yourself.";
        }
    } else {
        if (roleLabel) {
            roleLabel.textContent = "You are NOT the imposter!";
            roleLabel.className = 'role-label innocent';
        }
        if (wordDisplay) {
            wordDisplay.textContent = this.secretWord;
            wordDisplay.className = 'prompt-card large innocent';
        }
        if (instructionLabel) {
            instructionLabel.textContent = "Discuss clues about the word to find the imposter!";
        }
    }
}
```
  </action>
  <verify>
Check that all handlers are implemented:
- handleConsensusWarning
- handleConsensusCountdown
- handleConsensusCancelled
- handleRevealStart
- handleRevealResult
- handleVotingResumed
- handleWordRevealed

And that handleRoleAssignment resets voting state.
  </verify>
  <done>
All voting phase handlers implemented:
- Consensus warning with countdown display
- Reveal with dramatic pause
- Result with imposter/innocent styling
- Voting resume after result
- Word revealed for eliminated imposters
- State reset on new game
  </done>
</task>

</tasks>

<verification>
End-to-end test:
1. Start Imposter game with 3+ players (multiple browser tabs as web players)
2. Press V on host to start voting
3. Verify web players see voting view with player list
4. Tap a player to vote - verify vote count updates
5. Have all players vote for same person - verify consensus warning appears
6. Watch countdown tick down
7. Have one player change vote - verify consensus cancels, returns to voting
8. Re-create consensus, let countdown complete
9. Verify reveal view shows "Revealing..."
10. Verify result shows with correct color (red for imposter, green for innocent)
11. If imposter caught, verify they see spectator view with word
12. Verify voting resumes for remaining players
</verification>

<success_criteria>
- Players can tap to vote, see vote counts update in real-time
- Own vote shows highlighted border
- Vote changes are instant and can happen during consensus warning
- Consensus warning shows pulsing red with countdown
- Countdown cancels and returns to voting if consensus breaks
- Reveal shows dramatic "Revealing..." pause
- Result shows correct color (red imposter, green innocent)
- Eliminated imposters see the secret word
- Voting resumes after result display
- All requirements fully covered: VOTE-01, VOTE-02, VOTE-03, VOTE-04, ELIM-01, ELIM-02, ELIM-03, ELIM-04
</success_criteria>

<output>
After completion, create `.planning/phases/02-voting-elimination/02-03-SUMMARY.md`
</output>
